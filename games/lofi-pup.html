<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Procedural Lofi Station</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Inter:wght@300;400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
        }

        .retro-text {
            font-family: 'VT323', monospace;
        }

        .crt-overlay {
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        /* Gentle pulse animation for the speakers */
        @keyframes pulse-speaker {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.02);
            }

            100% {
                transform: scale(1);
            }
        }

        .bumping {
            animation: pulse-speaker 0.4s ease-out;
        }
    </style>
</head>

<body
    class="h-screen w-screen overflow-hidden flex flex-col items-center justify-center text-stone-300 relative bg-stone-900">

    <!-- Background Ambience -->
    <div
        class="absolute inset-0 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMWExYTFhIi8+CjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiMyMzIzMjMiLz4KPC9zdmc+')] opacity-50 z-0">
    </div>
    <div class="absolute inset-0 bg-gradient-to-t from-black via-transparent to-stone-900 z-0 opacity-80"></div>

    <!-- Main Player Container -->
    <div class="relative z-10 w-full max-w-md p-6">

        <!-- Tape Deck Visual -->
        <div
            class="bg-stone-800 rounded-lg shadow-2xl border-t border-stone-700 p-6 flex flex-col gap-6 relative overflow-hidden">
            <!-- decorative screws -->
            <div class="absolute top-2 left-2 w-2 h-2 rounded-full bg-stone-600"></div>
            <div class="absolute top-2 right-2 w-2 h-2 rounded-full bg-stone-600"></div>
            <div class="absolute bottom-2 left-2 w-2 h-2 rounded-full bg-stone-600"></div>
            <div class="absolute bottom-2 right-2 w-2 h-2 rounded-full bg-stone-600"></div>

            <!-- Screen / Visualizer -->
            <div
                class="bg-black border-4 border-stone-700 rounded-md h-32 relative flex items-center justify-center overflow-hidden group">
                <canvas id="visualizer" class="absolute inset-0 w-full h-full opacity-60"></canvas>
                <div class="crt-overlay absolute inset-0 z-20"></div>
                <div id="status-text" class="retro-text text-amber-500 text-2xl z-30 tracking-widest animate-pulse">
                    Ready...</div>

                <!-- Cassette Wheels Animation (Pure CSS) -->
                <div id="tape-wheels"
                    class="absolute inset-0 flex justify-center items-center gap-12 opacity-0 transition-opacity duration-500">
                    <div
                        class="w-16 h-16 border-4 border-stone-600 rounded-full flex items-center justify-center animate-[spin_4s_linear_infinite]">
                        <div class="w-2 h-2 bg-white rounded-full"></div>
                        <div class="absolute w-full h-1 bg-stone-800"></div>
                        <div class="absolute w-1 h-full bg-stone-800"></div>
                    </div>
                    <div
                        class="w-16 h-16 border-4 border-stone-600 rounded-full flex items-center justify-center animate-[spin_4s_linear_infinite]">
                        <div class="w-2 h-2 bg-white rounded-full"></div>
                        <div class="absolute w-full h-1 bg-stone-800"></div>
                        <div class="absolute w-1 h-full bg-stone-800"></div>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex flex-col gap-4">

                <!-- Main Transport -->
                <div class="flex justify-center items-center gap-6">
                    <button id="play-btn"
                        class="w-16 h-16 rounded-full bg-amber-600 hover:bg-amber-500 text-stone-900 flex items-center justify-center shadow-lg transition-all active:scale-95 group">
                        <i data-lucide="play" class="w-8 h-8 fill-current group-[.playing]:hidden"></i>
                        <i data-lucide="square" class="w-6 h-6 fill-current hidden group-[.playing]:block"></i>
                    </button>
                </div>

                <!-- Sliders -->
                <div class="grid grid-cols-1 gap-4 mt-2">
                    <div class="space-y-1">
                        <div class="flex justify-between text-xs font-bold tracking-wider text-stone-500 uppercase">
                            <span>Lofi Filter</span>
                            <span id="filter-val">50%</span>
                        </div>
                        <input type="range" id="filter-slider" min="100" max="3000" value="800"
                            class="w-full h-2 bg-stone-900 rounded-lg appearance-none cursor-pointer accent-amber-600">
                    </div>

                    <div class="space-y-1">
                        <div class="flex justify-between text-xs font-bold tracking-wider text-stone-500 uppercase">
                            <span>Vinyl Crackle</span>
                            <span id="crackle-val">30%</span>
                        </div>
                        <input type="range" id="crackle-slider" min="0" max="100" value="15"
                            class="w-full h-2 bg-stone-900 rounded-lg appearance-none cursor-pointer accent-amber-600">
                    </div>

                    <div class="space-y-1">
                        <div class="flex justify-between text-xs font-bold tracking-wider text-stone-500 uppercase">
                            <span>Tape Wobble</span>
                            <span id="wobble-val">Medium</span>
                        </div>
                        <input type="range" id="wobble-slider" min="0" max="50" value="15"
                            class="w-full h-2 bg-stone-900 rounded-lg appearance-none cursor-pointer accent-amber-600">
                    </div>
                </div>

                <!-- Meta Info -->
                <div class="text-center mt-2">
                    <p id="chord-display" class="text-stone-500 text-sm h-5 font-mono">--</p>
                </div>
            </div>
        </div>

        <p class="text-center text-stone-600 text-xs mt-6">
            Generative Audio Engine | Web Audio API<br>
            No Samples Used
        </p>
    </div>

    <script>
        // Init Icons
        lucide.createIcons();

        // Audio Context
        let audioCtx;
        let isPlaying = false;
        let nextNoteTime = 0.0;
        let timerID;
        let beatCount = 0;

        // Nodes
        let masterGain;
        let compressor;
        let vinylGain;
        let vinylNode;
        let analyser;

        // Settings
        const lookahead = 25.0; // ms
        const scheduleAheadTime = 0.1; // s
        const bpm = 80;

        // Canvas
        const canvas = document.getElementById('visualizer');
        const canvasCtx = canvas.getContext('2d');

        // UI Elements
        const playBtn = document.getElementById('play-btn');
        const statusText = document.getElementById('status-text');
        const tapeWheels = document.getElementById('tape-wheels');
        const filterSlider = document.getElementById('filter-slider');
        const crackleSlider = document.getElementById('crackle-slider');
        const wobbleSlider = document.getElementById('wobble-slider');
        const chordDisplay = document.getElementById('chord-display');

        // Music Theory Data (Jazzy/Lofi Chords)
        // Root notes relative to C (0)
        // Structures: 0=Root, 3=Min3, 4=Maj3, 7=Perf5, 10=Min7, 11=Maj7, 14=9
        const chords = [
            { name: "Cmaj9", notes: [0, 4, 7, 11, 14] }, // C E G B D
            { name: "Am9", notes: [-3, 0, 4, 7, 11] }, // A C E G B (Actually Am9 relative to C major key logic is tricky, simplifying to intervals)
            // Let's use specific MIDI-like offsets for simplicity
            // Key of C Majorish
            { name: "Dm9", offsets: [50, 53, 57, 60, 64] }, // D F A C E
            { name: "G13", offsets: [55, 59, 62, 65, 69] }, // G B F A E (Shell voicing)
            { name: "Cmaj9", offsets: [48, 52, 55, 59, 62] }, // C E G B D
            { name: "Am11", offsets: [57, 60, 64, 67, 71] }, // A C E G B
            { name: "Fmaj7", offsets: [53, 57, 60, 64] },     // F A C E
            { name: "Em7", offsets: [52, 55, 59, 62] },     // E G B D
            { name: "Ebmaj7", offsets: [51, 55, 58, 62] },     // Borrowed chord (Nice lofi vibe)
            { name: "Abmaj7", offsets: [56, 60, 63, 67] }      // Borrowed
        ];

        let currentChordIndex = 0;
        let chordProgression = [2, 3, 4, 1]; // Indices of chords array

        // --- Audio Engine Setup ---

        async function initAudio() {
            if (audioCtx) return;
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();

            // Master Chain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 0.5;

            // Compressor to glue it together
            compressor = audioCtx.createDynamicsCompressor();
            compressor.threshold.value = -20;
            compressor.knee.value = 30;
            compressor.ratio.value = 12;
            compressor.attack.value = 0.003;
            compressor.release.value = 0.25;

            // Analyser for visualizer
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;

            // Connect Chain
            masterGain.connect(compressor);
            compressor.connect(analyser);
            analyser.connect(audioCtx.destination);

            // Start ambiance
            createVinylCrackle();

            // Start Visualizer
            drawVisualizer();
        }

        // --- Instruments ---

        function createKick(time) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();

            osc.connect(gain);
            gain.connect(masterGain);

            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);

            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

            osc.start(time);
            osc.stop(time + 0.5);

            // Slight visual bump
            const icon = document.querySelector('[data-lucide="play"]');
            if (icon && isPlaying) {
                // Trigger simple CSS animation logic if needed, 
                // but we'll rely on the visualizer mostly.
            }
        }

        function createSnare(time) {
            // Noise burst
            const bufferSize = audioCtx.sampleRate * 0.5; // 0.5s
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            noiseFilter.type = 'highpass';
            noiseFilter.frequency.value = 1000;
            const noiseGain = audioCtx.createGain();

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);

            noiseGain.gain.setValueAtTime(0.4, time);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            noise.start(time);

            // Triangle "tone" underneath
            const osc = audioCtx.createOscillator();
            osc.type = 'triangle';
            const oscGain = audioCtx.createGain();
            osc.connect(oscGain);
            oscGain.connect(masterGain);

            osc.frequency.setValueAtTime(200, time);
            oscGain.gain.setValueAtTime(0.2, time);
            oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

            osc.start(time);
            osc.stop(time + 0.2);
        }

        function createHiHat(time) {
            const bufferSize = audioCtx.sampleRate * 0.1;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;

            const bandpass = audioCtx.createBiquadFilter();
            bandpass.type = 'bandpass';
            bandpass.frequency.value = 10000;

            const highpass = audioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 7000;

            const gain = audioCtx.createGain();

            noise.connect(bandpass);
            bandpass.connect(highpass);
            highpass.connect(gain);
            gain.connect(masterGain);

            // Randomize velocity slightly
            const velocity = 0.05 + Math.random() * 0.05;

            gain.gain.setValueAtTime(velocity, time);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);

            noise.start(time);
        }

        function playChord(time, duration) {
            // Pick next chord in progression
            const chordObj = chords[chordProgression[currentChordIndex % chordProgression.length]];
            currentChordIndex++;

            // Visual Update
            setTimeout(() => {
                if (isPlaying) chordDisplay.innerText = chordObj.name;
            }, (time - audioCtx.currentTime) * 1000);

            // Create nodes for polyphony
            const chordGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();

            // Lofi Filter settings (controlled by slider)
            filter.type = 'lowpass';
            filter.frequency.value = parseInt(filterSlider.value);
            filter.Q.value = 1;

            // Tape Wobble (LFO)
            const lfo = audioCtx.createOscillator();
            const lfoGain = audioCtx.createGain();
            lfo.type = 'sine';
            lfo.frequency.value = 0.5 + Math.random(); // Slow wobble
            lfoGain.gain.value = parseInt(wobbleSlider.value); // Wobble depth

            lfo.connect(lfoGain);

            chordGain.connect(filter);
            filter.connect(masterGain);

            chordObj.offsets.forEach(midiNote => {
                const osc = audioCtx.createOscillator();
                osc.type = Math.random() > 0.5 ? 'triangle' : 'sine'; // Mix waveforms

                // Midi to Freq conversion
                const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
                osc.frequency.value = freq;

                // Connect LFO to detune for wobble
                lfoGain.connect(osc.detune);

                // Envelope
                const noteGain = audioCtx.createGain();
                noteGain.gain.value = 0.15 / chordObj.offsets.length; // Normalize volume

                osc.connect(noteGain);
                noteGain.connect(chordGain);

                osc.start(time);
                osc.stop(time + duration);

                // ADSR-ish
                noteGain.gain.setValueAtTime(0, time);
                noteGain.gain.linearRampToValueAtTime(0.08, time + 0.1); // Attack
                noteGain.gain.linearRampToValueAtTime(0.05, time + 0.3); // Decay
                noteGain.gain.setValueAtTime(0.05, time + duration - 0.5); // Sustain
                noteGain.gain.linearRampToValueAtTime(0, time + duration); // Release
            });

            lfo.start(time);
            lfo.stop(time + duration);
        }

        function createVinylCrackle() {
            // Buffer size of 2 seconds
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);

            // Pink-ish noise generation
            let lastOut = 0;
            for (let i = 0; i < bufferSize; i++) {
                const white = Math.random() * 2 - 1;
                // Simple Brown/Pink filter
                const out = (lastOut + (0.02 * white)) / 1.02;
                lastOut = out;
                data[i] = out * 3.5; // boost level

                // Add random "pops"
                if (Math.random() > 0.9995) {
                    data[i] = (Math.random() * 2 - 1) * 0.8;
                }
            }

            vinylNode = audioCtx.createBufferSource();
            vinylNode.buffer = buffer;
            vinylNode.loop = true;

            vinylGain = audioCtx.createGain();
            const crackleVol = parseInt(crackleSlider.value) / 500; // scaling
            vinylGain.gain.value = isPlaying ? crackleVol : 0;

            vinylNode.connect(vinylGain);
            vinylGain.connect(masterGain);
            vinylNode.start();
        }

        // --- Scheduler ---

        function scheduleNote(beatNumber, time) {
            // Humanize rhythm slightly (swing/drunk)
            const swing = (beatNumber % 2 === 1) ? 0.05 : 0;
            const humanize = (Math.random() - 0.5) * 0.02;
            const triggerTime = time + swing + humanize;

            // Drums Pattern (Simple Boom Bap)
            // 0: Kick
            // 1: Hihat
            // 2: Snare + Hihat
            // 3: Hihat
            // 4: Kick + Kick Ghost
            // 5: Hihat
            // 6: Snare
            // 7: Hihat

            if (beatNumber % 8 === 0) {
                createKick(triggerTime);
                // New Chord every 16 beats (2 bars) or 8 beats (1 bar)
                if (beatNumber % 16 === 0) {
                    // Change progression occasionally
                    if (Math.random() > 0.7) {
                        chordProgression = chordProgression.sort(() => Math.random() - 0.5);
                    }
                    playChord(triggerTime, (60 / bpm) * 16); // Hold for 4 bars equivalent
                } else if (beatNumber % 8 === 0) {
                    // Sometimes retrigger chord logic here if we want faster changes
                    // playChord(triggerTime, (60/bpm) * 8); 
                }
            }

            if (beatNumber % 8 === 4) {
                createKick(triggerTime);
            }

            // Occasional ghost kick
            if (beatNumber % 8 === 3 && Math.random() > 0.7) {
                createKick(triggerTime + 0.2);
            }

            if (beatNumber % 8 === 2 || beatNumber % 8 === 6) {
                createSnare(triggerTime);
            }

            // Hi-hats every 8th note
            createHiHat(triggerTime);
            // Occasional 16th note hat
            if (Math.random() > 0.8) {
                createHiHat(triggerTime + ((60 / bpm) / 2));
            }
        }

        function nextNote() {
            const secondsPerBeat = 60.0 / bpm;
            // We are scheduling 8th notes
            nextNoteTime += 0.5 * secondsPerBeat;
            beatCount++;
        }

        function scheduler() {
            while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
                scheduleNote(beatCount, nextNoteTime);
                nextNote();
            }
            if (isPlaying) {
                timerID = requestAnimationFrame(scheduler);
            }
        }

        // --- Visualizer ---

        function drawVisualizer() {
            requestAnimationFrame(drawVisualizer);

            if (!analyser) return;

            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Resize canvas if needed
            if (canvas.width !== canvas.offsetWidth) {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
            }

            const width = canvas.width;
            const height = canvas.height;

            canvasCtx.clearRect(0, 0, width, height);

            // Draw "Wave" style
            canvasCtx.lineWidth = 2;
            canvasCtx.strokeStyle = 'rgba(217, 119, 6, 0.8)'; // Amber-600
            canvasCtx.beginPath();

            const sliceWidth = width * 1.0 / bufferLength;
            let x = 0;

            // Only draw lower frequencies mainly
            for (let i = 0; i < bufferLength; i++) {
                const v = dataArray[i] / 128.0;
                const y = height - (v * height / 1.5); // scaling

                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);

                x += sliceWidth;
            }

            canvasCtx.stroke();
        }

        // --- UI Interactions ---

        playBtn.addEventListener('click', async () => {
            if (!isPlaying) {
                await initAudio();

                // Reset time if needed to prevent mass catchup
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                nextNoteTime = audioCtx.currentTime + 0.1;
                beatCount = 0;

                isPlaying = true;
                scheduler();

                // Update UI
                playBtn.classList.add('playing');
                statusText.innerText = "PLAYING...";
                statusText.classList.remove('animate-pulse');
                tapeWheels.classList.remove('opacity-0');

                // Enable vinyl
                if (vinylGain) vinylGain.gain.setValueAtTime(parseInt(crackleSlider.value) / 500, audioCtx.currentTime);

            } else {
                isPlaying = false;
                window.cancelAnimationFrame(timerID);

                // Update UI
                playBtn.classList.remove('playing');
                statusText.innerText = "PAUSED";
                statusText.classList.add('animate-pulse');
                tapeWheels.classList.add('opacity-0');

                // Silence vinyl
                if (vinylGain) vinylGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        });

        // Sliders
        filterSlider.addEventListener('input', (e) => {
            document.getElementById('filter-val').innerText = e.target.value + "Hz";
            // The value is read dynamically in playChord
        });

        crackleSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            document.getElementById('crackle-val').innerText = val + "%";
            if (vinylGain && isPlaying) {
                vinylGain.gain.setTargetAtTime(val / 500, audioCtx.currentTime, 0.1);
            }
        });

        wobbleSlider.addEventListener('input', (e) => {
            const val = e.target.value;
            let label = "Low";
            if (val > 20) label = "Med";
            if (val > 40) label = "High";
            document.getElementById('wobble-val').innerText = label;
        });

    </script>
</body>

</html>